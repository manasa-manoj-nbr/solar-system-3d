<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Solar System Simulation</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="app-container">
        <!-- 3D Canvas -->
        <div id="canvas-container">
            <canvas id="solar-system-canvas"></canvas>
            
            <!-- Loading screen -->
            <div id="loading-screen" class="loading-screen">
                <div class="loading-content">
                    <h2>Loading Solar System...</h2>
                    <div class="loading-spinner"></div>
                </div>
            </div>
            
            <!-- Planet info tooltip -->
            <div id="planet-tooltip" class="planet-tooltip hidden">
                <div class="tooltip-content">
                    <h3 id="tooltip-name"></h3>
                    <p id="tooltip-info"></p>
                </div>
            </div>
        </div>
        
        <!-- Control Panel -->
        <div class="control-panel">
            <div class="panel-header">
                <h2>Solar System Controls</h2>
                <button id="panel-toggle" class="btn btn--secondary btn--sm">Hide</button>
            </div>
            
            <div class="panel-content">
                <!-- Master Controls -->
                <div class="control-section">
                    <h3>Master Controls</h3>
                    <div class="control-group">
                        <button id="pause-resume" class="btn btn--primary">Pause</button>
                        <button id="reset-speeds" class="btn btn--secondary">Reset Speeds</button>
                    </div>
                    <div class="control-item">
                        <label class="form-label">Master Speed: <span id="master-speed-value">1.0x</span></label>
                        <input type="range" id="master-speed" class="speed-slider" min="0" max="5" step="0.1" value="1">
                    </div>
                </div>
                
                <!-- Planet Speed Controls -->
                <div class="control-section">
                    <h3>Planet Speeds</h3>
                    <div id="planet-controls" class="planet-controls">
                        <!-- Planet controls will be generated by JavaScript -->
                    </div>
                </div>
                
                <!-- Camera Controls -->
                <div class="control-section">
                    <h3>View Controls</h3>
                    <div class="control-group">
                        <button id="reset-camera" class="btn btn--outline btn--sm">Reset View</button>
                        <button id="toggle-labels" class="btn btn--outline btn--sm">Toggle Labels</button>
                    </div>
                </div>
                
                <!-- Info Section -->
                <div class="control-section">
                    <h3>Instructions</h3>
                    <div class="instructions">
                        <p><strong>Mouse:</strong> Drag to rotate, scroll to zoom</p>
                        <p><strong>Touch:</strong> Drag to rotate, pinch to zoom</p>
                        <p><strong>Hover:</strong> Over planets for information</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Three.js Library with OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // OrbitControls implementation
        (function() {
            'use strict';
            THREE.OrbitControls = function(object, domElement) {
                this.object = object;
                this.domElement = (domElement !== undefined) ? domElement : document;
                
                this.enabled = true;
                this.target = new THREE.Vector3();
                this.enableZoom = true;
                this.zoomSpeed = 1.0;
                this.enableRotate = true;
                this.rotateSpeed = 1.0;
                this.enablePan = true;
                this.keyPanSpeed = 7.0;
                this.autoRotate = false;
                this.autoRotateSpeed = 2.0;
                this.enableDamping = false;
                this.dampingFactor = 0.25;
                this.minDistance = 0;
                this.maxDistance = Infinity;
                this.minZoom = 0;
                this.maxZoom = Infinity;
                this.minPolarAngle = 0;
                this.maxPolarAngle = Math.PI;
                this.minAzimuthAngle = -Infinity;
                this.maxAzimuthAngle = Infinity;
                this.enableKeys = true;
                
                var scope = this;
                var EPS = 0.000001;
                var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };
                var state = STATE.NONE;
                
                var spherical = new THREE.Spherical();
                var sphericalDelta = new THREE.Spherical();
                var scale = 1;
                var panOffset = new THREE.Vector3();
                var zoomChanged = false;
                
                var rotateStart = new THREE.Vector2();
                var rotateEnd = new THREE.Vector2();
                var rotateDelta = new THREE.Vector2();
                
                var panStart = new THREE.Vector2();
                var panEnd = new THREE.Vector2();
                var panDelta = new THREE.Vector2();
                
                var dollyStart = new THREE.Vector2();
                var dollyEnd = new THREE.Vector2();
                var dollyDelta = new THREE.Vector2();
                
                this.update = function() {
                    var offset = new THREE.Vector3();
                    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
                    var quatInverse = quat.clone().inverse();
                    
                    var lastPosition = new THREE.Vector3();
                    var lastQuaternion = new THREE.Quaternion();
                    
                    return function update() {
                        var position = scope.object.position;
                        offset.copy(position).sub(scope.target);
                        offset.applyQuaternion(quat);
                        spherical.setFromVector3(offset);
                        
                        if (scope.autoRotate && state === STATE.NONE) {
                            rotateLeft(getAutoRotationAngle());
                        }
                        
                        spherical.theta += sphericalDelta.theta;
                        spherical.phi += sphericalDelta.phi;
                        spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));
                        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
                        spherical.makeSafe();
                        spherical.radius *= scale;
                        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
                        
                        scope.target.add(panOffset);
                        offset.setFromSpherical(spherical);
                        offset.applyQuaternion(quatInverse);
                        position.copy(scope.target).add(offset);
                        scope.object.lookAt(scope.target);
                        
                        if (scope.enableDamping === true) {
                            sphericalDelta.theta *= (1 - scope.dampingFactor);
                            sphericalDelta.phi *= (1 - scope.dampingFactor);
                            panOffset.multiplyScalar(1 - scope.dampingFactor);
                        } else {
                            sphericalDelta.set(0, 0, 0);
                            panOffset.set(0, 0, 0);
                        }
                        
                        scale = 1;
                        
                        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
                            lastPosition.copy(scope.object.position);
                            lastQuaternion.copy(scope.object.quaternion);
                            zoomChanged = false;
                            return true;
                        }
                        return false;
                    };
                }();
                
                function getAutoRotationAngle() {
                    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
                }
                
                function getZoomScale() {
                    return Math.pow(0.95, scope.zoomSpeed);
                }
                
                function rotateLeft(angle) {
                    sphericalDelta.theta -= angle;
                }
                
                function rotateUp(angle) {
                    sphericalDelta.phi -= angle;
                }
                
                function dollyIn(dollyScale) {
                    scale /= dollyScale;
                }
                
                function dollyOut(dollyScale) {
                    scale *= dollyScale;
                }
                
                function onMouseDown(event) {
                    if (scope.enabled === false) return;
                    event.preventDefault();
                    
                    if (event.button === 0) {
                        state = STATE.ROTATE;
                        rotateStart.set(event.clientX, event.clientY);
                    } else if (event.button === 1) {
                        state = STATE.DOLLY;
                        dollyStart.set(event.clientX, event.clientY);
                    } else if (event.button === 2) {
                        state = STATE.PAN;
                        panStart.set(event.clientX, event.clientY);
                    }
                    
                    scope.domElement.addEventListener('mousemove', onMouseMove, false);
                    scope.domElement.addEventListener('mouseup', onMouseUp, false);
                }
                
                function onMouseMove(event) {
                    if (scope.enabled === false) return;
                    event.preventDefault();
                    
                    if (state === STATE.ROTATE) {
                        rotateEnd.set(event.clientX, event.clientY);
                        rotateDelta.subVectors(rotateEnd, rotateStart);
                        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
                        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);
                        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);
                        rotateStart.copy(rotateEnd);
                    }
                }
                
                function onMouseUp(event) {
                    if (scope.enabled === false) return;
                    scope.domElement.removeEventListener('mousemove', onMouseMove, false);
                    scope.domElement.removeEventListener('mouseup', onMouseUp, false);
                    state = STATE.NONE;
                }
                
                function onMouseWheel(event) {
                    if (scope.enabled === false || scope.enableZoom === false || (state !== STATE.NONE && state !== STATE.ROTATE)) return;
                    event.preventDefault();
                    event.stopPropagation();
                    
                    if (event.deltaY < 0) {
                        dollyOut(getZoomScale());
                    } else if (event.deltaY > 0) {
                        dollyIn(getZoomScale());
                    }
                }
                
                scope.domElement.addEventListener('contextmenu', function(event) { event.preventDefault(); }, false);
                scope.domElement.addEventListener('mousedown', onMouseDown, false);
                scope.domElement.addEventListener('wheel', onMouseWheel, false);
                
                this.update();
            };
        })();
    </script>
    <script src="app.js"></script>
</body>
</html>